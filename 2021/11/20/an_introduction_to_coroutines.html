<html lang="english"><head><meta name="view-transition" content="same-origin"><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link href="https://darkwiiplayer.github.io/css/all.css" rel="stylesheet"><link href="https://darkwiiplayer.github.io/css/schemes/talia.css" rel="stylesheet"><link href="/css/site.css" rel="stylesheet"><style>	@import url('https://fonts.googleapis.com/css2?family=Raleway&display=swap');
	@import url('https://fonts.googleapis.com/css2?family=Open+Sans&display=swap');
	@import url('https://fonts.googleapis.com/css2?family=Fira+Code&display=swap');

	:root { container: style; }
	:is(h1, h2, h3, h4, h5, h6) { font-family: "Raleway", sans-serif; }
	:is(code, kbd, var, samp) { font-family: "Fira Code", monospace; }
	.badge { font-family: "Open Sans", sans-serif }
</style><title>An Introduction to Coroutines</title><meta name="author" content="Talia"><meta content="2021-11-20" property="article:published_time"><meta content="https://tech.lgbt/@darkwiiplayer" property="article:author"><meta content="An Introduction to Coroutines" property="og:title"><meta content="Talia's Blog" property="og:site_name"><meta content="A language-agnostic introduction to the concept of Coroutines" property="og:description"><meta content="article" property="og:type"><meta content="Talia" property="og:article:author"><meta content="coroutines" property="og:article:tag"><meta content="parallelism" property="og:article:tag"></head><body><header class="sticky" style="view-transition-name: header"><h1>Talia's Blog</h1><nav class="right bar"><ul><li><a href="/">Home</a></li></ul></nav></header><main><article><h1 style="view-transition-name: an_introduction_to_coroutines">An Introduction to Coroutines</h1><div tabindex="0" class="summary">A language-agnostic introduction to the concept of Coroutines</div><vertical-spacer></vertical-spacer><flex-row gap=".4" style="justify-content: flex-start"><post-tag><a style="--color: rgb(98, 89, 165)" href="/?tag=coroutines" tabindex="0">coroutines</a></post-tag><post-tag><a style="--color: rgb(89, 137, 165)" href="/?tag=parallelism" tabindex="0">parallelism</a></post-tag></flex-row><vertical-spacer></vertical-spacer><nav class="breadcrumbs"><ul><li><a tabindex="0" href="/blog/">Blog</a></li><li><a tabindex="0" href="/2021">2021</a></li><li><a tabindex="0" href="/2021/11">11</a></li><li><a tabindex="0" href="/2021/11/20">20</a></li><li class="active">An Introduction to Coroutines</li></ul></nav><vertical-spacer></vertical-spacer><aside class="box"><b>Hey there!</b><p>		This blog doesn't use any tracking. When you open this page, I don't see
		a number going up anywhere, so if you like this post, please consider
		letting me know on <a href="https://tech.lgbt/@darkwiiplayer">the fediverse</a>!
		This is also the best way of giving any other feedback on my blog posts.
	</p><p><i>Thank you.</i></p></aside><h2>Preamble</h2>
<p>The aim of this article is to be a mostly language-agnostic introduction to coroutines. All code used will be a pseudocode, which will somewhat resemble JavaScript.</p>
<ul>
<li>Subroutines are defined as <code>arguments ⇒ body</code></li>
<li>Subroutines without arguments will be shortened to <code>⇒ body</code></li>
<li>Multi-statement subroutines use braces <code>{}</code></li>
</ul>
<h2>What are Coroutines?</h2>
<p>In describing coroutines, the introductory sentence of the <a href="https://en.wikipedia.org/wiki/Coroutine">wikipedia article</a> already gets very close to the way I would describe it:</p>
<blockquote>
<p><strong>Coroutines</strong> are <a href="https://en.wikipedia.org/wiki/Computer_program" title="Computer program">computer program</a> components that generalize <a href="https://en.wikipedia.org/wiki/Subroutine" title="Subroutine">subroutines</a> for <a href="https://en.wikipedia.org/wiki/Non-preemptive_multitasking" title="Non-preemptive multitasking">non-preemptive multitasking</a>, by allowing execution to be suspended and resumed.</p>
</blockquote>
<p>Put even more simply: A coroutine is <em>like a function</em> that can pause itself.
If we think of a normal function, the way it works is that we <strong>call</strong> the function, the function <strong>executes</strong> and at some point, it <strong>returns</strong> back to where it was called.</p>
<p>In a similar way, a very simple coroutine will do the same thing: We will <strong>create</strong> the coroutine, it will <strong>execute</strong> and at some point it will end and (implicitly) <strong>yield</strong> back to the calling code.</p>
<p>Here is a simple example of how this looks in practice.</p>
<p>First we define a new coroutine that yields three times and finally prints &quot;Done&quot;</p>
<pre><code class="language-js">my_coro = coroutine(=&gt; {
    yield(1)
    yield(2)
    yield(3)
    print(&quot;Done&quot;)
})
</code></pre>
<p>Now we can resume the coroutine up to 4 times, and each time it will resume from the last <code>yield</code> and stop at the next one, or when it reaches the end of the subroutine.</p>
<pre><code>first_yield = resume(coro)
// At this point the coroutine is paused on its first line
print(first_yield) // prints 1

second_yield = resume(coro)
// At this point the coroutine is paused on its second line
print(second_yield) // prints 2

third_yield = resume(coro)
// At this point the coroutine is paused on its third line
print(third_yield) // prints 3

resume(coro) // prints &quot;Done&quot;
// At this point the coroutine has completed its execution.
</code></pre>
<p>The big difference is: A coroutine can <strong>yield</strong> more than once, and will be paused in between. And that is really all there is to them, from a technical level. A simple example of this would look like this.</p>
<h2>Classifying Coroutines</h2>
<p>The 2004 paper <a href="http://www.inf.puc-rio.br/~roberto/docs/MCC15-04.pdf">Revisiting Coroutines</a> classifies coroutines in two important ways: <em>Symmetric vs. Asymmetric</em> and <em>Stackful vs. Stackless</em>. The paper also distinguishes on whether coroutines are handled as values by the language, but that distinction is less important to understanding how they fundamentally work.</p>
<h3>Control Transfer Mechanism</h3>
<p>The way coroutines transfer control can happen in two ways.</p>
<p>Asymmetric coroutines are more similar to how functions work. When a coroutine <em>A</em> resumes a coroutine <em>B</em>, <em>B</em> will at some point yield back to <em>A</em>, just like how any function will eventually return to its caller. We can think of these coroutines as organised in a stack, just like how functions are, but this is not the same as being <em>stackful</em>.</p>
<p>An important implication of this type of control transfer is that once a coroutine hands over control to another by resuming it, it can only ever be handed back control from this coroutine. In other words, it cannot be <em>resumed</em> from the outside, as it is already &quot;running&quot;, only <em>yielded</em> to.</p>
<p>To illustrate this: &quot;When you lend a pencil to Bob, you know you will eventually get the pencil back from Bob and nobody else.&quot;</p>
<p>This will be represented in pseudocode by the functions <code>resume</code> (&quot;hand control down&quot;) and <code>yield</code> (&quot;return control back up&quot;)</p>
<p>In the previous section, the example represented this kind of coroutine. It handed over control three times using the <code>yield</code> function without specifying where to hand control back to. It simply went back to wherever the coroutine was resumed from.</p>
<hr />
<p>Symmetric coroutines work a bit differently. Coroutines can freely transfer control to any other coroutine, instead of just &quot;up and down&quot;.</p>
<p>Unlike asymmetric coroutines, this one-way control transfer means a coroutine can hand over control to another and be handed back control by a completely different one.</p>
<p>Continuing the pencil analogy: &quot;When you lend a pencil to Bob, you may later get it back from Steve, Larry, or never get it back at all.&quot;</p>
<p>In pseudocode, this will be represented by the <code>transfer</code> function.</p>
<hr />
<p>The main advantage of asymmetric coroutines is that they offer more structure. Symmetric coroutines let the user freely jump back and forth between coroutines, in a similar way to <code>goto</code> statements, which grants a much higher degree of freedom but can also make code hard to follow.</p>
<h3>Stackfulness</h3>
<p>Another important way to categorize coroutines is whether every coroutine has its own stack. This distinction is much harder to explain in theory, but will become clear in examples later on.</p>
<p>Stackless coroutines, as the name implies, don't have their own call stack. What this means in practice is that the program has no way of tracking their call stack once they yield control, so this is only possible from the function on the bottom of the stack.</p>
<p>Stackful coroutines, on the other hand, have a separate stack for every coroutine, so they can be paused from anywhere inside the coroutine.</p>
<p>A complete explanation of why this is and how it works could easily be its own article, so I will be skipping it for now. The important part to remember here is that Stacful is &quot;better&quot; in that it lets you do more, but also harder to implement in a language, specially if it was added later on and not part of the initial language design.</p>
<hr />
<p>Many programming languages actually have <em>stackless</em> <em>asymmetric</em> coroutines; JavaScript, for example, calls them <em>generators</em>.</p>
<p>Some languages even have a mix of both: Ruby <em>fibers</em> can both use <code>resume</code>/<code>yield</code> semantics, but they can also freely transfer control freely with the <code>transfer</code> method.</p>
<p>Windows even provides an OS-level API for coroutines: It calls them Fibers, and they are <em>stackful</em> and <em>symmetric</em>. Linux does not provide any coroutine API yet.</p>
<h2>Why are they useful?</h2>
<p>On an abstract level, the strength of coroutines is to manage state. Since they remember where they left off for the next time they're resumed, they can use control-flow to save state that would otherwise have to be stored in variables.</p>
<h3>Animation</h3>
<p>As a simple example, imagine an object in a game. The object has an <code>update</code> function that will be called repeatedly by the engine, and as an argument, it will receive the time (in seconds) since the last time it was called. This is a very typical setup for simpler games.</p>
<p>Implementing a simple animation, for example, along the edges of a square, would require storing the animation state in some sort of data-structure so the <code>update</code> function knows where to continue the animation. Although in this case one <em>might</em> be able to get away with just <code>x</code> and <code>y</code> coordinates (which are likely already present in the object) and some convoluted if/else logic, this code would still look unintuitive.</p>
<p><strong>Coroutines to the rescue!</strong> Now consider extending the setup like this:</p>
<p>Along with the <code>x</code> and <code>y</code> attributes, the object also has a <code>behavior</code> coroutine. The only thing the <code>update</code> method does, is to resume this coroutine every time.</p>
<pre><code>object.update = delta_time ⇒ resume(object.behavior, delta_time)
</code></pre>
<p><code>resume</code>, in this pseudocode language, is the function that resumes a suspended coroutine asymmetrically, meaning it will pause the code here until the resumed coroutine yields.</p>
<p>For this to work, a bit of extra semantics has to be introduced: Just how functions can have <em>arguments</em>, it is common that <em>yielding</em> and <em>resuming</em> coroutines can also pass arguments along. In the above pseudocode, this will be represented as an extra argument to both <code>resume</code> and <code>yield</code>, that would be <em>returned</em> by the matching <code>yield</code> and <code>resume</code> calls. This is a very common way to handle passing around data between asymmetric coroutines.</p>
<p>Now, with this setup, the <code>behavior</code> coroutine could look something like this:</p>
<pre><code>object.behavior = coroutine( ⇒ {
	while true {
		while object.x &lt; 10
			object.x += yield() * object.speed
		while object.y &lt; 10
			object.y += yield() * object.speed
		while object.x &gt; 0
			object.x -= yield() * object.speed
		while object.y &gt; 0
			object.y -= yield() * object.speed
	}
)
</code></pre>
<p>where <code>coroutine</code> is a function that takes a subroutine and turns it into a coroutine, without actually starting it and <code>yield</code> is a function that suspends the current coroutine and yields back to the &quot;parent&quot; coroutine that resumed it.</p>
<p>It looks a bit like magic. The animation code <em>looks</em> like it should simply block the game in an endless loop, but it doesn't, because it runs inside a coroutine that yields after every step. But the state of the animation is still represented as a simple nested loop.</p>
<p>This can be taken a step further though. Consider the following example:</p>
<pre><code>object.behavior = coroutine ( ⇒ {
	while true {
		object.move_right(10)
		object.move_down(10)
		object.move_left(10)
		object.move_up(10)
	}
})

object.move_right = distance ⇒ {
	while distance &gt; 0
		delta_x = yield() * object.speed
		object.x += delta_x
		distance -= delta_x
}
</code></pre>
<p>This could be refactored into a single <code>move(axis, distance)</code> function, of course; but the additional code to figure out the direction would clutter the code a bit too much for this example.</p>
<p>The important thing here is, that the top-level function of the coroutine never <code>yield</code>s; instead, it calls a <code>move_*</code> function that takes care of yielding itself. This is where <strong>stackfulnes</strong> comes into play again: Only <strong>stackful</strong> coroutines can do this. In languages with stackless coroutines, like javascript, code like this would likely be rejected by the compiler.</p>
<p>Put very simply: the reason for this is that when <code>move_right</code> yields, it needs to remember where it needs to return to after it resumes. This information is what's on the stack, so a coroutine without its own stack cannot remember from nested functions.</p>
<h3>I/O Event Loops</h3>
<p>Another application of coroutines is handling the complexity if asynchronous code. Lua has done this for years now, Ruby recently adopted the same idea, and languages like Elixir have been doing a very similar thing as part of the language for ages.</p>
<p>But how exactly can coroutines help with this? Simple: by yielding to an event-loop, which will resume them once a certain event happens. While in practice this is a bit more complicated, the core idea is this:</p>
<ul>
<li>All code runs inside coroutines (In some languages this is always the case, in others it would be up to a framework to run any user code in a coroutine)</li>
<li>Functions that need to await asynchronous tasks simply start an I/O operation, then yield some object describing when to resume them back to the top level coroutine</li>
<li>When a coroutine yields, a scheduler will decide what coroutine to resume next, or simply sleep until any new &quot;event&quot; is available.</li>
</ul>
<p>This should sound very familiar to anybody who has worked with <code>async</code>/<code>await</code> before. It is a very similar concept. Then only difference is that functions are always synchronous, and all functions are implicitly awaited.</p>
<p>This has one significant advantage: While the program itself either uses non-blocking IO or APIs that resume it whenever any of the awaited inputs is available, the user writes codes that <em>looks</em> like blocking code. And it is in fact &quot;blocking&quot;, on the level of the coroutine, but will never block other parts  of the same program.</p>
<p>At the same time, this is still cooperative multi-threading, so no section of code will be interrupted from the outside. Only operations that yield can lead to race-conditions, but two consecutive non-yielding operations will never have their state messed with in between.</p>
<p>This makes unsafe code much easier to spot:</p>
<pre><code>c = global(counter)
c = c + 1
global(counter) = c
</code></pre>
<p>The above code is very obviously safe, because the code will never be suspended for other code to run in the meantime.</p>
<p>In a multi-threaded environment, this code could lead to errors: the scheduler could suspend this thread after the first line, and some other thread could increment the counter. Then, when this thread was resumed, the third line would overwrite the <code>counter</code> variable with an old value.</p>
<hr />
<p>With coroutines, it is still possible to write buggy code susceptible to race-conditions, but only by explicitly yielding, or calling a function that does so.</p>
<pre><code>c = global(counter)
c = c + 1
sleep(3)
global(counter) = c
</code></pre>
<p>This code is obviously unsafe: in the 3 seconds that this coroutine is sleeping, some other code may also increment the counter, which would then be overwritten by this coroutine after it resumes.</p>
<p>However, we can safely assume that the code will <em>never</em> be interrupted between the first and the second line, or even worse, in between two steps of the same line.</p>
<hr />
<h2>Conclusion</h2>
<p>There is, of course, lots more to be said about coroutines, and how they a reintegrated in different languages. But this introduction should give a good enough idea of how they fundamentally work.</p>
</article></main><footer class="box"><grid-box columns="3" class="content-padding"><aside id="contact"><h2>Social</h2><p>Got feedback? — Tag me on fedi!<br><a rel="me" href="https://tech.lgbt/@darkwiiplayer">@darkwiiplayer@tech.lgbt</a></p></aside><aside id="git"><h2>Git</h2><ul><li><a href="https://github.com/darkwiiplayer">Github</a></li><li><a href="https://git.but.gay/darkwiiplayer">Gitea</a></li></ul></aside><aside id="platforms"><h2>Federated cloud</h2><p>darkwiiplayer@cloud.but.gay</p></aside></grid-box></footer></body></html>