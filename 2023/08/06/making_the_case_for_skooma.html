<html lang="english"><head><meta content="same-origin" name="view-transition"><meta charset="UTF-8"><meta content="width=device-width" name="viewport"><link rel="stylesheet" href="https://darkwiiplayer.github.io/css/all.css"><link rel="stylesheet" href="https://darkwiiplayer.github.io/css/schemes/talia.css"><style>	@import url('https://fonts.googleapis.com/css2?family=Raleway&display=swap');
	@import url('https://fonts.googleapis.com/css2?family=Open+Sans&display=swap');
	@import url('https://fonts.googleapis.com/css2?family=Fira+Code&display=swap');

	:root { container: style; }
	:is(h1, h2, h3, h4, h5, h6) { font-family: "Raleway", sans-serif; }
	:is(code, kbd, var, samp) { font-family: "Fira Code", monospace; }
	.badge { font-family: "Open Sans", sans-serif }
</style><title>Making the case for Skooma</title><meta content="Talia" name="author"><meta property="article:published_time" content="2023-08-06"><meta property="article:author" content="https://tech.lgbt/@darkwiiplayer"><meta property="og:title" content="Making the case for Skooma"><meta property="og:site_name" content="Talia's Blog"><meta property="og:description" content="In this short post I present a simple personal library I wrote for myself to  handle HTML generation in JavaScript, compare it to many of its alternatives, and evaluate whether it was worth the time investment of not just picking an existing library."><meta property="og:type" content="article"><meta property="og:article:author" content="Talia"><meta property="og:article:tag" content="html"><meta property="og:article:tag" content="javascript"><meta property="og:article:tag" content="templating"></head><body><header class="sticky"><h1>Talia's Blog</h1><nav class="right bar"><ul><li><a href="/">Home</a></li></ul></nav></header><main><aside class="box"><b>Hey there!</b><p>		This blog doesn't use any tracking. When you open this page, I don't see
		a number going up anywhere, so if you like this post, please consider
		letting me know on <a href="https://tech.lgbt/@darkwiiplayer">the fediverse</a>!
		This is also the best way of giving any other feedback on my blog posts.
	</p><p><i>Thank you.</i></p></aside><article><h1 style="view-transition-name: making_the_case_for_skooma">Making the case for Skooma</h1><nav class="breadcrumbs"><ul><li><a href="/blog/">Blog</a></li><li><a href="/2023">2023</a></li><li><a href="/2023/08">08</a></li><li><a href="/2023/08/06">06</a></li><li class="active">Making the case for Skooma</li></ul></nav><h2>Introduction</h2>
<p>Skooma.js is a small library I built for myself to solve the problem of generating dynamic HTML from vanilla JavaScript. It's an adaptation of a Lua library of the same name to JS, with some additional quality of life improvements that only work because it runs in the browser.</p>
<p>The point of this post is not to convince anyone to use it. The API is relatively stable and it seems relatively bug-free by now, but this is still primarily intended as my personal helper library. Instead I want to make an argument for why I think it was a good idea to build it.</p>
<h2>History</h2>
<p>Skooma, as mentioned above, started out as a Lua library to generate HTML on the server side. The core concept is simple: for every HTML (or XML) tag, there is a function that takes the tags contents and returns some representation of the tag. While the library allows users to mutate the returned elements (represented as a reeeeeally simple DOM structure), the library itself is free of side-effects (with the exception of certain helpers that are explicitly about side effects), so it works well with a functional approach.</p>
<p>You can map an array of strings with the <code>span</code> function to turn it into an array of <code>span</code> elements containing the strings as their text. Complex structures (&quot;components&quot;) can easily be composed as new functions.</p>
<p>The primary motivation for this library was a general dissatisfaction with existing ways of writing HTML. Plain HTML and most templating languages are cumbersome to write. And while modern editors make the experience a lot less painful, with features like auto-closing tags, it still seems a bit backwards to need such heavy tooling to just write it.</p>
<p>Some of the more DLS-like templating languages like HAML get a lot closer to what I want, but I am really not a fan of having a separate DSL that is not quite its host language, not quite HTML and also not quite its own language.</p>
<p>A better approach, in my mind, was the one found in the <a href="http://leafo.net/lapis/">lapis</a> framework, where html is generated from Lua functions (usually moonscript compiled to Lua, which makes for cleaner code) that can be nested. I also wrote my own iteration of this concept in the form of MoonHTML, but eventually abandoned the project because emitting the HTML as a side-effect instead of returning it came with a variety of scalability problems that made it easier for smaller templates but more complex in bigger projects.</p>
<p>The result was eventually Skooma (named after a fictional drug in the Elder Scrolls universe, made from a substance called <em>moon sugar</em>), which I still use to this day whenever I have the need to generate some HTML programmatically or just don't feel like typing out the actual HTML.</p>
<p>Given the many similarities between Lua and JavaScript, it was only a matter of time for me to decide to port the concept from one language to another, and the fact that browsers already have a DOM API means that whole part of the library can be removed and the result is still more powerful than working with my custom mini DOM.</p>
<h2>Features</h2>
<p>Skooma is best explained by exmaple, as a big part of the point is the (relatively) clean-looking code that looks <em>somewhat</em> like a purpose-built DSL.</p>
<pre><code class="language-js">import {html} from '/skooma.js'

const user = ({name, email, picture}) =&gt;
	html.div({class: 'user'},
		html.img({src: picture}),
		html.h2(name),
		html.a(email, {href: `mailto:${email}`})
	)

fetch_users_from_somewhere()
	.map(user)
	.each(document.body.append)
</code></pre>
<p>In this example, I define a simple <code>user</code> component that takes an object with some attributes and generates a DOM structure to represent it. The HTML object is a proxy that generates functions for generating DOM nodes as writing <code>html.div(content)</code> is a lot nicer than <code>html.tag(&quot;div&quot;, content)</code>. <code>Proxy</code> really is a vastly underrated JavaScript feature.</p>
<p>The outermost <code>div</code> tag is given three other tags as its children, and an object representing its HTML attributes. This API is very flexible; one can pass several child elements and objects in whatever order and even nest them in arrays (which can then be re-used).</p>
<h3>Event Handlers</h3>
<p>Since passing functions into HTML attributes makes no sense, this case is used for setting event handlers instead:</p>
<pre><code class="language-js">html.button(&quot;Click me!&quot;, {click: event =&gt; alert(&quot;Button has been clicked!&quot;)})
</code></pre>
<p>This internally uses <code>addEventListener</code> instead of setting an <code>onclick</code> attribute, so this even lets one add several handlers of the same type, albeit in separate objects.</p>
<h3>Initialisers</h3>
<p>Just like with attributes, putting a function in the child-list of a DOM element makes no sense, so this case is used to simply pass arbitrary initialisers to the element. These get called as soon as they're found instead of deferred, so any arguments that follow will not yet be applied. I have no strong opinion on whether deferring them would make more sense and might implement this if I ever find a good reason to prefer it.</p>
<pre><code class="language-js">const register = element =&gt; { my_element_registry.add(element) }
// ^ pretend this gets used somewhere else to do something useful

html.button(&quot;Click me?&quot;, register)
</code></pre>
<h3>Dataset</h3>
<p>Data-attributes can instead be set by passing a special <code>dataset</code> object key to an element constructor:</p>
<pre><code class="language-js">const form_children = [/* ... */]
html.form({
	'data-id': '0001', // this is ugly
	dataset: { id: '0001' }, // this is nicer
}, form_children)

// Excessively hacky and ugly:
html.form(
	Object.fromEntries(Object.entries(user).map(
		([key, value]) =&gt; [&quot;data-&quot;+key, value])
	),
	form_children
)

// This is how things should be:
html.form({dataset: user}, form_children)
</code></pre>
<h3>Shadow-Root</h3>
<p>Likewise, the key <code>shadowRoot</code> is also special, in that its value is added to the new object's shadow root, which is created if it doesn't exist yet. This follows the same logic as the function's arguments, so it can be a DOM node, a string, or a (possibly nested) array of child elements.</p>
<pre><code class="language-js">html.div({
	shadowRoot: [
		html.h2(&quot;Greetings from the shadow DOM!&quot;),
		html.slot(),
		html.span(&quot;It's very shadowy in here...&quot;)
	]
}, html.i(&quot;Wait, where am I?!&quot;))
</code></pre>
<h3>Styling</h3>
<p>Similar to <code>dataset</code>, the <code>style</code> attribute can be used to pass an object and have its values assigned to the DOM node's <code>style</code> attribute.</p>
<pre><code class="language-js">html.span({
	style: {
		textDecoration: 'underline',
		// gets transformed to kebab-case
	}
})
</code></pre>
<h3>Custom Elements</h3>
<p>Custom elements, which have hyphens in their names, don't have to be created using square braces (although you can, if you hate yourself) <code>html['my-component'](&quot;inner text&quot;)</code>; instead, camelCase tag names are converted to kebab-case just like style properties and html attributes, so you can just write <code>html.myComponent(&quot;inner text&quot;)</code> instead.</p>
<pre><code class="language-js">html.typeWriter({
	customProperty: &quot;I have a property!&quot;,
}, [
	html.span(&quot;Greetings, I am a custom element&quot;),
])
</code></pre>
<h2>As a Learning Experience</h2>
<p>All in all, this was a really fun project to implement. <code>Proxy</code> objects are really nice, and porting the code from Lua, which has a completely different way of doing a very similar thing, was ultimately still really easy. And even though I only used a small part of the <code>Proxy</code> API, I still used the chance to read up on some of the other possibilities it offers. <code>Proxy</code> is cool!</p>
<h2>Comparing to Alternatives</h2>
<h3>Interpolation++</h3>
<p>Comparing skooma.js to anything from <code>String ${'templates'}</code> to traditional PHP, where you still write HTML but can interpolate content into your output and sometimes even insert blocks of logic into it, skooma does as good a job as all the alternatives below at getting rid of my primary problem: HTMLs annoying syntax.</p>
<h3>HAML &amp; Co.</h3>
<p>These templating &quot;languages&quot; honestly aren't bad. I am perfectly happy writing HAML templates whenever I'm having to work with rails, and any of its alternatives in other languages would work as well.</p>
<p>My main problems with these are the context-switching between languages, and the fact that it's not nearly as easy to refactor by extracting common structures into sub-components, as you can't just draw them out into a function and use it later on.</p>
<h3>VanJS</h3>
<p>Had I found this library before writing Skooma, I probably would have just used it instead. It does basically the same thing, albeit with less convenience features, and will most likely still use this for work projects, as it has the benefit of being a &quot;proper&quot; framework (i.e. I didn't write it myself and it has a fancy website), so it will simply seem more legitimate to coworkers. Gotta love workplace politics.</p>
<p>I will say though, that I am not at all a fan of how it encourages importing all the tag functions into the current scope. That just screams scalability nightmare, and in any bigger project this will inevitably lead to a) lots of unused tag functions still being declared and b) constant &quot;why isn't it wor— oh I haven't imported <code>ul</code> yet&quot;</p>
<p>But that's just a style choice and the library doesn't force you to do things that way.</p>
<h3>Skooma (Lua)</h3>
<p>This is, to me, the gold standard of syntax. Lua has some small advantages in its syntax that make it easier to make code look nice:</p>
<ol>
<li>Ommitting braces when calling a function with a table literal as its only argument</li>
<li>Tables acting both as arrays and maps</li>
<li>Semicolons being allowed instead of commas (I hate commas for multi-line things)</li>
<li>Overriding <code>_ENV</code> and loading code with custom environments</li>
</ol>
<p>So the <code>user</code> component from my first example could instead be written like this:</p>
<pre><code class="language-lua">function user(u)
	return div{
		class = &quot;user&quot;;
		img { src = u.picture };
		h2 { name };
		a {
			email;
			href: &quot;mailto:&quot; .. u.email
		}
	}
end
</code></pre>
<p>And if I want to instead write it in moonscript or yuescript, a language (and a dialect of it) that compiles to Lua, I could even write my component like this:</p>
<pre><code class="language-moon">user ==&gt;
	div class: &quot;user&quot;
		* img src: @picture
		* h2 name
		* a email, href: &quot;mailto:#{@email}&quot;
</code></pre>
<p>which is starting to look almost like an actual DSL, except it's not, and I can put as much &quot;real programming logic&quot; like loops, function calls, etc. right in my HTML code and the syntax is the exact same between logic and template.</p>
<p>Admittedly, I could <em>probably</em> achieve the same in JS if I used something like CoffeeScript.</p>
<h2>Conclusions</h2>
<ol>
<li>Writing this library was definitely worth it. It was fun, I got to practise using <code>Proxy</code> and the result is definitely quite usable. I would absolutely do this again and encourage anyone to try projects like this one even if just for the fun aspect alone.</li>
<li>I already am and will continue to use skooma.js for my personal projects. Once I got used to it, it just feels weird to imagine using things like JSX or even assembling DOM nodes by hand using browser APIs.</li>
<li>I can't really be bothered to lobby people to use my cute little project and turn it into a &quot;real thing&quot;, but if you're interested, or maybe even use VanJS and want to see how it compares, by all means, use Skooma. It's as production-ready as a single dev can make it, and due to its simplicity, bugs happen rarely and can usually be fixed within half an hour. Documentation is available at <a href="https://darkwiiplayer.github.io/js/skooma.html">darkwiiplayer.github.io/js/skooma.html</a></li>
</ol>
</article></main></body></html>